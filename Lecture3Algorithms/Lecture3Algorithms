we are going to think particularly on the How to think algorithmically ?

Our moto is to get the problem and try to solve it with the help of the algorithms and develop a metality which is going to help us solve problems.
What is an array ? An array is a sequence of a characters indexed from 0 to n , where n is the number of elements. 
It is stored in a consective manner aka contigous .It is stored in an contigous manner. 

searching
searching is basically checking whether the information is available or not . Search can be performed in many things. 
Linear search - Any time you search from Left or from the right to the end is called Linear search 
It is same as walking in the line , doesn't matter which way it is . 


let's discuss about the pseudo code - 
incase we are finding any value -
while(to the end){
    if (value ==50)
    return true;
return false ; 
}

So the pseudo code is basically the idea to identify the code , or the instructions which we are trying to find . 



Binary Search (Divide and conquer){

}
    while condition (start < end){
start with the middle 
   if (the number is equal to 50)
        return true;
    else if (number < 50 ){
        start =
        end = 

    }   
    else if (number > 50 ){
        start =
        end = 
    } 
    }
   
   return false ;

   so whenever you are starting  with the programming language , start with writting the code which is pseudo code .
   When u have the objective about what needs to be done , the program becomes a lot easy .


   now lets discuss the running time of these algorithms -

   while discussing about the time and efficiency of an algorithm , they come across an term which is mentioned below.
   Big O notation - it tells about the algorithm is going to perform with the increase in the size of the problme .
   Big O always gives us the upper bound and its always the worst case scenario. 

    
   O(n *n) - It is the 2 for loop . 
   O(n log n) - It is the 
   O(n)- it is the linear search .
   O(log n)- It is the best time possible.  This is the Binary search .
   O(1)- It is the constant time which we care about . 


   Omega gives us the lower bound . It gives us the lower bound and best possible scenario. 
   omega(1) - It is best case for the linear and the binary search 



   Lets translate this in the binary search .


   need to implement linear search with number 
#include <stdio.h>
#include <string.h>

#include <cs50.h>


int main(void){
    int numbers[] = {2,3,4,65,44,33,55,47};
    for(int i = 0;i<8;i++){
        if(numbers[i]==85){
            printf("Found\n");
            return 0;
        }


    }
    printf("Not Found\n");
    return 1;


}


   need to implement linear search with strings .
   #include <stdio.h>
#include <string.h>

#include <cs50.h>


int main(void){
    string strings[] = {"Kishan","Software","Badminton","Public Speaker","Motivator","Funny","Genuine"};
    for(int i = 0;i<8;i++){
        if(strcmp(strings[i],"Software")==0){
            printf("Found\n");
            return 0;
        }


    }
    printf("Not Found\n");
    return 1;


} 

   Implement phonebook 

   #include <stdio.h>
#include <string.h>

#include <cs50.h>


int main(void){
    string names[] = {"Kishan","Software","Badminton","Public Speaker","Motivator","Funny","Genuine"};
    string phoneNumber[]={"34243","34324","3422334","34234","342234","342342","34234","32423"};
    for(int i = 0;i<8;i++){
        if(strcmp(names[i],"Software")==0){
            printf("Found and the number is %s\n", phoneNumber[i]);
            return 0;
        }


    }
    printf("Not Found\n");
    return 1;


}



   It is best said that when you dont want to do any math on the numbers , take it as a string . 



Data structures - 
Array was part of the data structure but then we want to bring out the new ways to store the values better . 

Lets talk about the typedef

typedef struct{
    string name ;
    string number;

} person;

#include <stdio.h>
#include <string.h>
#include <cs50.h>

typedef struct{
    string name;
    string number;
}person;

int main(void){
    string name = get_string("Enter the name : ");
    person people[3];
    people[0].name = "Kishan";
    people[0].number = "8133012298";
    people[1].name = "Agarwalla";
    people[1].number = "8133012298";
    people[2].name = "Assam";
    people[2].number = "8133012298";
    for(int i = 0;i<3;i++){
        if(strcmp(people[i].name,name)==0){
            printf("Found and the number is %s\n", people[i].number);
            return 0;
        }


    }
    printf("Not Found\n");
    return 1;


}



Sorting - How much time and money is invested to sort the data. 
We have seen this multiple times that the pseudo code helps to write the code  better . It helps us to think better and execute the code better . 


The first sorting algorithmns we are going to talk about is the 
Selection sorting 

check for the smallest number till the (n-i) position . 
replace the small number with teh numers[i] position . 

It is run at the O(n*n) 

Bubble sort is again o(n*n)

need to implement selection sort 
need to implement bubble sort 
need to implement basic recursion for the pyramid


Recursion - it is the way of calling the function itself again and again. It uses the function's memory in a very efficient manner is very helpful .



Merge sort - It is the fastest one.  it is nlogn time 
So in computer science there is a trade off between time and memory . 
So, if u use more memory , ultimately this will reduce the work or complete the work in faster time . 
whereas if u dont want to use more memory , this will take more time to sort the algorithms. 